### 修饰符

> * `g`: 全文搜索
> * `i` : ignore 忽略带小学
> * `m`: multiple lines 多行搜索

### 元字符

在正则表达式中 有特殊含义的非字母字符

> `.` : 匹配任意字符  
> `+` : 匹配前面的子表达式一次或多次。相当于`{1,}`  
> `?` : 匹配前面的子表达式零次或一次。相当于`{0,1}`  
> `$` : 匹配输入字符串的结束位置  
> `^` : 匹配输入字符串的开始位置（反向类）  
> `|` :  或  
> `\` :  转义字符  
> `()` :  分组  
> `[]` : 字符集合。匹配所包含的任意一个字符。  
> `*` : 匹配前面的子表达式零次或多次.相当于`{0,}`

`[]` **模糊匹配**

```js
'a1b2c3'.replace(/[abc]/g,'X'); //"X1X2X3" 解析：匹配括号内的任意字符
'a1b2c3'.replace(/[^abc]/g,'X'); //"aXbXcX" 解析：不匹配括号内的任意字符
```

**范围类**

```js
'a1b2c3'.replace(/[a-c]/g,'X'); //"X1X2X3" 匹配a-c范围内的字母
```

**预定义类**

`\d`** : \(\[0-9\]\)  ===》 **`\D`** : **非数字字符

`\s`** : 空白符 ===》 **`\S`** ：**非空白符

`\w`** : \[a-zA-Z\_0-9\] **单词字符** ===》 **`\W`** : **\[^a-zA-Z\_0-9\] 非单词符

`.`** : \[^\r\n\]  **除了回车符合换行符之外的所有字符

demo 匹配一个ab+数字+任意字符的字符串

```js
ab[0-9][^\r\n]
ab\d. //使用预定义类
```

**边界**

`^` : 以xxx开始

`$` : 以xxx结束

`\b` : 单词边界 ===》 `\B : 非单词边界`

```js
'This is a boy'.replace(/is/g,'0');      //"Th0 0 a boy"
'This is a boy'.replace(/\bis\b/g,'0');  //"This 0 a boy"
```

```js
'@123@abc@'.replace(/@./g,'Q');  // "Q23Qbc@"  匹配@+任意字符
'@123@abc@'.replace(/^@./g,'Q'); // "Q23@abc@" 匹配以@开头
'@123@abc@'.replace(/.@/g,'Q');  // "@12QabQ"  匹配任意字符+@
'@123@abc@'.replace(/.@$/g,'Q'); // "@12@abQ"  匹配任意字符+@结尾
```

**量词**

`?` : 匹配前面的子表达式零次或一次。相当于`{0,1}`

`+` : 匹配前面的子表达式一次或多次。相当于`{1,}`

`*` : 匹配前面的子表达式零次或多次.相当于`{0,}`

```js
/\d+/  // 至少出现一次
```

**贪婪模式与非贪婪模式**

1. 贪婪模式： 让正则表达式尽可能多的匹配 **默认**
2. 非贪婪模式：让正则表达式尽可能少匹配，也就是说一旦匹配成功就不再继续尝试。
   1. 做法很简单，在量词后面加上`?` 即可

```js
'12345678'.replace(/\d{3,6}/g,'X') // 'X78' 
'12345678'.replace(/\d{3,6}?/g,'X') // 'XX78' 解析 匹配到3个则停止 接着匹配
'12345678'.match(/\d{3,6}?/g) //   ["123", "456"]
```

**分组**

有时候我们想匹配到某段字符 ger{3} 这样写会发现r重复3次而不是我们想要的ger重复3次

使用`()` 可以达到分组的功能，使量词作用于分组。下例实现匹配3次 字符+数组

```js
'a1b2c3d4'.replace(/[a-z]\d{3}/g,'X') // "a1b2c3d4"
'a1b2c3d4'.replace(/([a-z]\d){3}/g,'X') // "Xd4"
```

反向引用 替换日期 2018-05-21

```js
'2018-05-21'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$2-$3-$1') //"05-21-2018"
```

**前瞻**

* 正向前瞻 `exp(?=assert)`
* 父向前瞻 `exp(?!assert)`

看个例子 \w\(?=\d\) 匹配到单词字符后向后看看是不是数字

```js
'a2*3'.replace(/\w(?=\d)/g,'X') // "X2*3"
'a2*34v8'.replace(/\w(?=\d)/g,'X') //"X2*X4X8"
```

---

**实战**

富文本的移动端适配 

```js
//要求 width 属性置为空，style 中的 width 为100%
var str = '<div style="width: 800px; height: 100px;"><img width="500" height="200" /></div>'
```

```js
// 去掉img里的width属性
str = str.replace(/([a-z]+)="[\s\S]+?"/ig,function($1,$2,$3){
    console.log($1);   //$1是匹配到的 也是要替换的字符串
    // style="width: 800px; height: 100px;"
    // width="500"
    // height="200"
    
    console.log($2);
    // style
    // width
    // height

    if($2== 'width'){
        return '';
    }
    return $1;
})
==> "<div style="width: 800px; height: 100px;"><img  height="200" /></div>"
```

```js
// style 里的width属性置为100%
str.replace(/width:\s\d{3,4}px;/g,'width: 100%');
"<div style="width: 100% height: 100px;"><img  height="200" /></div>"
```



