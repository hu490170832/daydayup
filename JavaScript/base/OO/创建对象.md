# 创建对象的模式

## 工厂模式

```js
function createPerson(name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function () {
        alert(this.name);
    };
    return o;
}
var person1 = createPerson("Nicholas", 29, "Software Engineer");
var person2 = createPerson("Greg", 27, "Doctor");
```

工厂模式虽然解决了创建  
多个相似对象的问题，但却没有解决对象识别的问题法识别创建的对象的类型。因为全部都是Object，没有区分度，不像Date、Array等，因此出现了构造函数模式

## 构造函数模式

```js
function Person(name){ 
   this.name = name; 
   this.showName = function(){ 
     alert(this.name);
   } 
} 
var p1 =new Person('haha'); 
p1.showName();
var p2 = new Person('hehe'); 
p2.showName();
```

我们注意到， Person\(\) 中的代码  
除了与 createPerson\(\) 中相同的部分外，还存在以下不同之处：

* 没有显式地创建对象；
* 直接将属性和方法赋给了 this 对象；
* 没有 return 语句。

此外，还应该注意到函数名 Person 使用的是大写字母 P。按照惯例，构造函数始终都应该以一个  
大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他 OO 语言，主要是为了  
区别于 ECMAScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。  
要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4  
个步骤：

1. 创建一个新对象；
2. 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；
3. 执行构造函数中的代码（为这个新对象添加属性）；
4. 返回新对象。

**举个例子**

```js
function Person(name){
   this.name = name;
   this.showName = function(){
     alert(this.name); 
   }; 
    console.log(this);
} 
new Person('haha'); //Person
Person('haha');  //window
```

我们会发现当用New去调用一个函数的时候，this的指向会不一样。其实New主要做了下面这些事，不过下面写的只是大概的行为，并不是内部源码

```js
function Person(name){ 
   var obj = {}; //声明一个空对象obj 
   obj._proto_= Person.prototype;
   //把这个对象的_proto_属性指向构造函数的原型对象,这样obj就可以调用Person原型对象下的所有方法 ，这里原型先知道结论，下面会讲。
    Person.apply(obj);   //用apply方法让this指向obj对象
    this.name = name;   //obj对象添加属性，方法
    this.showName = function(){ 
       alert(this.name);
      }; 
    return obj;//返回这个对象
}
```

**函数构造模式存在的问题：**

```js
alert(p1.showName==p2.showName);//false
```

**可见这两个对象并不是共用一个方法**，每new一次，系统都会新创建一个内存，这两个对象各自有各自的地盘，但他们具有相同的功能，还不共用，肯定不是我们所希望的。所以就有了下一种方法，原型+构造模式 ==&gt;原型模式

## 原型模式

我们创建的每个函数都有一个 `prototype` （原型）属性，**这个属性是一个指针，指向一个对象**，而这个对象的用途是包含可以由特定类型的**所有实例共享的属性和方法**。如果按照字面意思来理解，那  
么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以  
让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是  
可以将这些信息直接添加到原型对象中，如下面的例子所示。

```js
function Person(name){ 
  this.name = name;
}
Person.prototype.showName = function(){ 
   alert(this.name);
}
var p1 =new Person('haha');
p1.showName();
var p2 = new Person('hehe');
p2.showName();
alert(p1.showName==p2.showName);//true
```

测试为true，可见showName\(\)方法是共享的，也就是说他们共用一个内存，更进一步的说它们存在引用关系，也就是说你更改了p1的showName也会影响p2的showName

#### **\_proto\_属性**:

同一个函数造出来的实例对象能共享这个函数的prototype下的方法和属性，但是它是如何做到的呢？这里要出场的就是\_proto\_属性.

每个实例化对象都有\_proto\_属性，它是一个指针，指向函数的prototype，也就是保存了它的地址。（**JS中任何对象的值都是保存在堆内存中，我们声明的变量只是一个指针，保存了这个对象的实际地址，所以有了地址就能找到对象**）



