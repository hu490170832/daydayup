### 页面重排与重绘

1、重绘\(Repaint\)

重绘是一个元素外观的改变所触发的浏览器行为，例如改变outline、背景色等属性。浏览器会根据元素的新属性重新绘制，

使元素呈现新的外观。重绘不会带来重新布局，所以并不一定伴随重排。

2、重排\(Reflow\)

渲染对象在创建完成并添加到渲染树时，并不包含位置和大小信息。计算这些值的过程称为布局或重排

"重绘"不一定需要"重排"，比如改变某个网页元素的颜色，就只会触发"重绘"，不会触发"重排"，因为布局没有改变。但是，"重排"必然导致"重绘"，比如改变一个网页元素的位置，就会同时触发"重排"和"重绘"，因为布局改变了。

3、常见的触发重排的操作

Reflow 的成本比 Repaint 的成本高得多的多。DOM Tree 里的每个结点都会有 reflow 方法，一个结点的 reflow 很有可能导致子结点，甚至父点以及同级结点的 reflow。在一些高性能的电脑上也许还没什么，但是如果 reflow 发生在手机上，那么这个过程是非常痛苦和耗电的。

1. **添加或者删除可见的DOM元素**
2. **元素位置改变**
3. **元素尺寸改变**
4. **元素内容改变（例如：一个文本被另一个不同尺寸的图片替代）**
5. **页面渲染初始化（这个无法避免）**
6. **浏览器窗口尺寸改变**

### JS 运行原理

```js
<!--执行结果是什么-->
var a = 2;
setTimeout(function(){
   a--;
});
a++
console.log(a);
```

题目还是比较简单，最终输出的是3.

问1：如果外面的a++循环一百万次呢，顺序如何？ 答，还是一样，setTimeout在后面

##### 问2：为什么会这样？===&gt; 同步会阻塞进程

执行过程

1 判断是否为同步 =》 是：放入执行栈中 执行；放入执行队列中，等执行栈空时，将队列依次取出，放入执行栈执行

### 给你一个需求让你写吧。有一个实时搜索的搜索框，连续输入的时候不触发实时搜索，当用户停下来1s以上时，再显示搜索结果

```js
<input type="text" id="input">
<script>
  window.onload = function () {
    let timer = null

    function search() {
      console.log(document.getElementById('input').value);
    }

    document.getElementById('input').addEventListener('input', () => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        search();
      }, 1000)
    })
  }
</script>
```

### 跨域

cors,jsonp,window.name

##### 问1：jsonp是怎么实现的

用JSON来传数据，靠JSONP来跨域。

JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。



## VUE 系列

---

##### 1、你觉得vue和JQ相比，有什么优势

维护更方便，以及数据渲染页面的方式使逻辑和页面分离，更加高效

**两个最大的优势，一个是双向绑定，一个是组件**

##### 

##### 2、写的时候为什么data不直接返回对象数据，而是要用函数的形式return出结果？

每个实例可以维护一份被返回对象的独立的拷贝：否则会共用数据。。。

##### 3、虚拟dom



